digraph "Graphical Class Hierarchy"
{
 // INTERACTIVE_SVG=YES
  bgcolor="transparent";
  edge [fontname="Helvetica",fontsize="10",labelfontname="Helvetica",labelfontsize="10"];
  node [fontname="Helvetica",fontsize="10",shape=record];
  rankdir="LR";
  Node1 [label="o2::header::BaseHeader",height=0.2,width=0.4,color="black",URL="$d8/dbd/structo2_1_1header_1_1BaseHeader.html",tooltip="the base header struct Every header type must begin (i.e. derive) with this. Don&#39;t use this struct di..."];
  Node1 -> Node2 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node2 [label="o2::emcal::EMCALBlockHeader",height=0.2,width=0.4,color="black",URL="$d3/d13/structo2_1_1emcal_1_1EMCALBlockHeader.html",tooltip="Header for EMCAL flagging the following EMCAL payload. "];
  Node1 -> Node3 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node3 [label="o2::framework::DataProcessing\lHeader",height=0.2,width=0.4,color="black",URL="$d7/df0/structo2_1_1framework_1_1DataProcessingHeader.html"];
  Node1 -> Node4 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node4 [label="o2::framework::DataSampling\lHeader",height=0.2,width=0.4,color="black",URL="$d2/d30/structo2_1_1framework_1_1DataSamplingHeader.html"];
  Node1 -> Node5 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node5 [label="o2::framework::OutputObj\lHeader",height=0.2,width=0.4,color="black",URL="$db/df3/structo2_1_1framework_1_1OutputObjHeader.html",tooltip="O2 header for OutputObj metadata. "];
  Node1 -> Node6 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node6 [label="o2::framework::SourceInfo\lHeader",height=0.2,width=0.4,color="black",URL="$d0/d7a/structo2_1_1framework_1_1SourceInfoHeader.html",tooltip="a BaseHeader with state information from the source "];
  Node1 -> Node7 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node7 [label="o2::header::DataHeader",height=0.2,width=0.4,color="black",URL="$db/d87/structo2_1_1header_1_1DataHeader.html",tooltip="the main header struct "];
  Node1 -> Node8 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node8 [label="o2::header::HeartbeatFrame\lEnvelope",height=0.2,width=0.4,color="black",URL="$d4/dfa/structo2_1_1header_1_1HeartbeatFrameEnvelope.html"];
  Node1 -> Node9 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node9 [label="o2::header::NameHeader\< N \>",height=0.2,width=0.4,color="black",URL="$d2/dda/structo2_1_1header_1_1NameHeader.html",tooltip="an example data header containing a name of an object as a null terminated char arr. this is a template! at instantiation the template parameter determines the size of the held string array. a caveat with decoding is (if length of string is not known) you have to use header::get<NameHeader<0>>(buffer) to get it out of a buffer. May improve in the future if enough people complain. If the compiler decides to pad the end of struct, the length of padding is stored in the last byte "];
  Node1 -> Node10 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node10 [label="o2::header::test::MetaHeader",height=0.2,width=0.4,color="black",URL="$da/d75/structo2_1_1header_1_1test_1_1MetaHeader.html"];
  Node1 -> Node11 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node11 [label="o2::tpc::TPCSectorHeader",height=0.2,width=0.4,color="black",URL="$d4/da3/structo2_1_1tpc_1_1TPCSectorHeader.html"];
  Node1 -> Node12 [dir="back",color="midnightblue",fontsize="10",style="solid",fontname="Helvetica"];
  Node12 [label="test::MetaHeader",height=0.2,width=0.4,color="black",URL="$dc/d68/structtest_1_1MetaHeader.html"];
}
