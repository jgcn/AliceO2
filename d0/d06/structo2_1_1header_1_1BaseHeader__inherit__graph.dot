digraph "o2::header::BaseHeader"
{
 // INTERACTIVE_SVG=YES
  bgcolor="transparent";
  edge [fontname="Helvetica",fontsize="10",labelfontname="Helvetica",labelfontsize="10"];
  node [fontname="Helvetica",fontsize="10",shape=record];
  Node1 [label="{o2::header::BaseHeader\n|+ magicString\l+ magicStringInt\l+ @26\l+ headerSize\l+ flags\l+ flagsNextHeader\l+ flagsUnused\l+ @28\l+ headerVersion\l+ description\l+ serialization\l+ sMagicString\l+ sVersion\l+ sHeaderType\l+ sSerializationMethod\l|+ BaseHeader()\l+ BaseHeader()\l+ BaseHeader()\l+ size()\l+ data()\l+ next()\l+ next()\l+ get()\l+ get()\l}",height=0.2,width=0.4,color="black", fillcolor="grey75", style="filled", fontcolor="black"];
  Node1 -> Node2 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node2 [label="{o2::emcal::EMCALBlockHeader\n|+ mHasPayload\l+ sHeaderType\l+ sVersion\l|+ EMCALBlockHeader()\l}",height=0.2,width=0.4,color="black",URL="$d3/d13/structo2_1_1emcal_1_1EMCALBlockHeader.html",tooltip="Header for EMCAL flagging the following EMCAL payload. "];
  Node1 -> Node3 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node3 [label="{o2::framework::DataProcessing\lHeader\n|+ startTime\l+ duration\l+ creation\l+ sHeaderType\l+ sVersion\l|+ DataProcessingHeader()\l+ DataProcessingHeader()\l+ DataProcessingHeader()\l+ DataProcessingHeader()\l+ getCreationTime()\l+ Get()\l}",height=0.2,width=0.4,color="black",URL="$d7/df0/structo2_1_1framework_1_1DataProcessingHeader.html"];
  Node1 -> Node4 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node4 [label="{o2::framework::DataSampling\lHeader\n|+ sampleTimeUs\l+ totalAcceptedMessages\l+ totalEvaluatedMessages\l+ deviceID\l+ sVersion\l+ sHeaderType\l+ sSerializationMethod\l+ deviceIDTypeSize\l|+ DataSamplingHeader()\l+ DataSamplingHeader()\l+ DataSamplingHeader()\l+ operator=()\l+ Get()\l}",height=0.2,width=0.4,color="black",URL="$d2/d30/structo2_1_1framework_1_1DataSamplingHeader.html"];
  Node1 -> Node5 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node5 [label="{o2::framework::OutputObj\lHeader\n|+ mPolicy\l+ sVersion\l+ sHeaderType\l+ sSerializationMethod\l|+ OutputObjHeader()\l+ OutputObjHeader()\l+ OutputObjHeader()\l}",height=0.2,width=0.4,color="black",URL="$db/df3/structo2_1_1framework_1_1OutputObjHeader.html",tooltip="O2 header for OutputObj metadata. "];
  Node1 -> Node6 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node6 [label="{o2::framework::SourceInfo\lHeader\n|+ state\l+ sHeaderType\l+ sVersion\l|+ SourceInfoHeader()\l+ SourceInfoHeader()\l+ Get()\l}",height=0.2,width=0.4,color="black",URL="$d0/d7a/structo2_1_1framework_1_1SourceInfoHeader.html",tooltip="a BaseHeader with state information from the source "];
  Node1 -> Node7 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node7 [label="{o2::header::DataHeader\n|+ dataDescription\l+ dataOrigin\l+ splitPayloadParts\l+ payloadSerializationMethod\l+ subSpecification\l+ splitPayloadIndex\l+ payloadSize\l+ sVersion\l+ sHeaderType\l+ sSerializationMethod\l|+ DataHeader()\l+ DataHeader()\l+ DataHeader()\l+ DataHeader()\l+ operator=()\l+ operator==()\l+ operator==()\l+ operator==()\l+ operator==()\l+ print()\l+ Get()\l}",height=0.2,width=0.4,color="black",URL="$db/d87/structo2_1_1header_1_1DataHeader.html",tooltip="the main header struct "];
  Node1 -> Node8 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node8 [label="{o2::header::HeartbeatFrame\lEnvelope\n|+ header\l+ trailer\l+ sVersion\l+ sHeaderType\l+ sSerializationMethod\l|+ HeartbeatFrameEnvelope()\l+ HeartbeatFrameEnvelope()\l}",height=0.2,width=0.4,color="black",URL="$d4/dfa/structo2_1_1header_1_1HeartbeatFrameEnvelope.html"];
  Node1 -> Node9 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node9 [label="{o2::header::NameHeader\< N \>\n|+ sVersion\l+ sHeaderType\l+ sSerializationMethod\l|+ NameHeader()\l+ NameHeader()\l+ getName()\l+ getNameLength()\l+ sHeaderType()\l+ sHeaderType()\l}",height=0.2,width=0.4,color="black",URL="$d2/dda/structo2_1_1header_1_1NameHeader.html",tooltip="an example data header containing a name of an object as a null terminated char arr. this is a template! at instantiation the template parameter determines the size of the held string array. a caveat with decoding is (if length of string is not known) you have to use header::get<NameHeader<0>>(buffer) to get it out of a buffer. May improve in the future if enough people complain. If the compiler decides to pad the end of struct, the length of padding is stored in the last byte "];
  Node1 -> Node10 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node10 [label="{o2::header::test::MetaHeader\n|+ secret\l+ sHeaderType\l+ sVersion\l|+ MetaHeader()\l}",height=0.2,width=0.4,color="black",URL="$da/d75/structo2_1_1header_1_1test_1_1MetaHeader.html"];
  Node1 -> Node11 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node11 [label="{o2::tpc::TPCSectorHeader\n|+ sector\l+ activeSectorsFlags\l+ activeSectors\l+ unused\l+ flags\l+ @20\l+ sHeaderType\l+ sVersion\l+ NSectors\l|+ TPCSectorHeader()\l}",height=0.2,width=0.4,color="black",URL="$d4/da3/structo2_1_1tpc_1_1TPCSectorHeader.html"];
  Node1 -> Node12 [dir="back",color="midnightblue",fontsize="10",style="solid",arrowtail="onormal",fontname="Helvetica"];
  Node12 [label="{test::MetaHeader\n|+ secret\l+ sHeaderType\l+ sVersion\l|+ MetaHeader()\l}",height=0.2,width=0.4,color="black",URL="$dc/d68/structtest_1_1MetaHeader.html"];
}
